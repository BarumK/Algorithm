- 탐욕적 알고리즘: 작업 스케줄링 문제
(1) 하나의 작업자와
(2) 시작 시간과 종료 시간 [s, f)로 표현되는 n개의 작업으로 이루어진 집합 J = {j1, ... , jn}가 주어졌을 때
작업자가 처리할 수 있는 작업의 수를 최대화할 수 있도록 작업을 선택하는 문제
    조건: (1) 작업자는 동시에 두 개의 일을 동시에 처리 못함
         (2) 각 작업은 시작해야 하는 시간과 끝내야 하는 시간이 있음

- 작업 스케줄링 탐욕적 알고리즘 설계 과정
선정 과정 & 적정성 검사: 현재 선택 가능 작업 중 가장 최적의 적업을 부분 해로 선택하고 적정성 검사 후 해 집합에 포함시킴
    부분 해 선택 기준? 직관적으로는 다양한 선택 기준이 존재
    짧은 작업 우선 선택 -> 짧으면 많이 하지 않을까? 라는 생각을 바탕으로
        선택 순간마다 (선정 과정) 해당 순간에 작업 지속 시간이 가장 적은 작업 우선 선택 후
                    (적정성 검사) 이전에 선택한 각 작업과 시간이 겹치지 않으면 해 집합에 포함하고 겹치면 선정 과정으로 되돌아감
                        -> 항상 최적인 최종 해를 도출해낼 수 없음. 반례는 AlGoGae_w6_04.png 참고
    시간이 겹치는 다른 작업의 수가 가장 적은 작업 우선 선택 -> 적으면 다른 거를 많이 하지 않을까? 라는 생각을 바탕으로
        선택 순간마다 (선정 과정) 해당 순간에 시간이 겹치는 ""남은 작업들의 수""가 가장 적은 작업을 우선적으로 선택 후
                    (적정성 검사)이전에 선택한 각 작업과 시간이 겹치지 않으면 해 집합에 포함하고 겹치면 선정 과정으로 되돌아감
                        -> 항상 최적인 최종 해를 도출해낼 수 없음. 반례는 AlGoGae_w6_04.png 참고
    빠른 시작 시간 작업 우선 선택
        선택 순간마다 (선정 과정) 해당 순간에 시작 시간이 가장 이른 작업을 우선적으로 선택 후
                    (적정성 검사)이전에 선택한 각 작업과 시간이 겹치지 않으면 해 집합에 포함하고 겹치면 선정 과정으로 되돌아감
                        -> 항상 최적인 최종 해를 도출해낼 수 없음. 반례는 AlGoGae_w6_04.png 참고
    빠른 종료 시간 작업 우선 선택
        선택 순간마다 (선정 과정) 해당 순간에 종료 시간이 가장 이른 작업을 우선적으로 선택 후
                    (적정성 검사)이전에 선택한 각 작업과 시간이 겹치지 않으면 해 집합에 포함하고 겹치면 선정 과정으로 되돌아감
                        -> 항상 최적인 최종 해를 도출할 수 있음. 증명이 있긴 함 코드는 AlGoGae_w6_05.py 참고
해답 점검: 주어진 모든 작업을 확인했는지 점검

- 작업 스케일링의 정확성 검증(항상 최적 해를 반환하는가? 항상 가장 많은 작업의 수를 반환하는가?)
정리 1: 이른 종료 시간 우선으로 보는 알고리즘의 경우 최종 해가 항상 최적이다.
    증명은 AlGoGae_w6_06.png 참고