- 탐욕적 알고리즘?
: 일련의 연속적인 부분 해 선택이 필요한 문제가 주어졌을 때, 선택을 해야 할 순간마다 그 순간에 최적이라고 생각되는 것을
  부분 해라고 선택함으로써 최종 해를 도출하는 알고리즘
    -> 매 선택할 때마다 현재 상황에서 가장 좋은 것을 선택하는 문제, 이 선택을 취합해서 최종 해를 도출하는 것
결국 하나의 큰 문제를 작은 문제들로 나누는 것(분할)
    분할 정복, 탐욕적, 동적 프로그래밍 전부 큰 문제를 작은 문제로 나눠서 처리한다는 점에서 동일함.
    차이는 나중에 세 가지를 전부 배운 후에 차이점을 다룰 예정
매 순간마다 최적의 부분 해를 찾지만 최종 해가 최적(더 이상 좋을 수 없는 결과)이라는 보장이 없음
    -> 해가 항상 최적인지 이론적으로 검증해야 하지만 매우 어려운 경우가 많음
    무조건 최적으로 찾아야 하는 것이 아니면 매우 유용한 알고리즘. 가장 간단함
    거의 최적에 가까운 최종 해(근사 해)를 도출하는 알고리즘을 휴리스틱이라 함

- 일반적인 탐욕적 알고리즘 설계 과정
선정 과정: 현재 가장 최적이라고 생각하는 부분 해를 선택하는 것
적정성 점검: 선택한 해를 최종 결과를 위한 해 집합에 포함시키는 것이 적절한지를 확인하고 적절하면 포함시키는 과정
해답 점검: 새로 얻은 해 집합이 주어진 문제의 최종(final) 해인지 확인. 즉 알고리즘 종료 조건
    -> 일단 뽑아보고, 적정하면 최종 해집합에 포함시키고, 답인지 확인
    주의: 최적인지 볼 필요는 없다 그건 이론적으로 따로 검증해야 함

- 탐욕적 알고리즘의 적용 예: 거스름돈 계산하기 문제
동전 여러 개를 가지고 거스름돈 x를 만들기 위한 최소 동전 개수?
AlGoGae_w6_02.py 참고
설계 과정
    선정 과정:현재 선택할 수 있는 동전 중 가장 액면가가 높은 동전을 부분해로 선택
        부분 해 선택 기준 타당 여부를 보이기 위한 방법 중 하나는 최종 해가 항상 최적이 아님을 보이는 반례를 찾는 것
        탐욕적 알고리즘 설계 과정에서 ""부분 해 선택 기준 선정""은 가장 중요한 고려 사항 중 하나
    적정성 점검: 해당 동전을 거스름돈에 추가 시 거스름돈 총액을 초과하는지 확인하여 초과하지 않았다면 해집합에 추가하고 초과했다면 선정과정으로 돌아감
    해답 점검: 현재까지의 금액(해 집합의 총액)이 거스름돈 총액에 도달했는지 확인
이 알고리즘으로 할 경우 동전의 개수는 항상 최소 -> 최종 해가 항상 최적임을 보장
How if 동전 시스템에 12원짜리가 추가된다면?
    -> 알고리즘대로 할 경우 12, 1, 1, 1, 1로 최적의 해(10, 5, 1) 보장 못함
    결국, 동전 시스템에 의해 최종 해의 최적 여부가 결정됨. 항상 최적인 해를 도출할 수 없음
but 탐욕적 알고리즘은 시간, 공간 효율성의 이유로 탐욕적 알고리즘을 이용해 최적에 근사한 근사 해를 도출해내는 경우가 많음
    예시: 위치 기반 배달 시스템 혹은 네비게이션 상 위치 안내 시스템. 굳이 정확하기보단 적당히 근사한 값을 빠르게 알려주는 것이 좋을 때도 있기에
    무조건 느리더라도 정확한 것보다 적당히 근사하고 빠른 결과를 도출하는 것이 필요할 때가 있기 때문