- 선택 문제
사이즈가 n인 정수 리스트의 원소 중 k 번째로 작은 원소를 찾는 문제
입력: 사이즈가 n인 정수 리스트 & 출력: k 번째로 작은 정수
단순한 방법: 리스트를 오름차순 정렬 후 k 번째 원소를 선택 -> O(nlogn)
    중요: 대소관계 비교에 의한 모든 정렬 알고리즘은 평균·최악의 경우 O(nlogn)보다 더 효율적일 수 없음!
    (오름차순) 정렬 → O(nlogn) + 리스트의 세 번째 인덱스 2가 가리키는 원소 4 반환 → O(1)

- 분할 정복 알고리즘 퀵 선택(quick selection) 설계 전략
분할: partition 함수를 이용하여 리스트 내 n 개의 원소 정렬 시 피벗을 기준으로 피벗보다 값이 작은 원소들을 피벗의 왼쪽으로 옮기고,
     피벗보다 값이 큰 원소들은 모두 피벗의 오른쪽으로 옮겨서 두 개의 서브리스트를 생성, i.e., 두 개의 부분 문제로 분할(추가 공간 X)
정복: k 번째로 작은 원소의 값이 피벗 값보다 작으면 왼쪽 서브리스트를 대상으로 (재귀적으로) 퀵 선택 실행, 크면 오른쪽 서브 리스트를 대상으로
     퀵 선택 실행 , 피벗 값과 같다면 피벗 값을 결과로 반환
통합: 필요 없음
quick selection의 핵심 아이디어
    정렬을 하지 않고 빠르게 k 번째 작은 원소를 찾을 수는 없을까?
    퀵 정렬에서 사용하는 partition 함수를 이용
예시: AlGoGae_w4_08.png 참고
코드: AlGoGae_w4_09.py 참고

- 퀵 선택의 수행 시간 분석
리스트 사이즈(입력 사이즈) n = 2k 라고 가정
최선의 경우와 평균의 경우 O(n)
    최선의 경우 퀵 정렬과 마찬가지로 k 번 균등 분할하는 경우이며, 이진 검색과 마찬가지로 각 분할마다 검색 공간이 1/2로 감소하므로 O(n)
    평균의 경우 피벗의 인덱스가 리스트 전체에 걸쳐서 균등하게 임의로 결정된다는 가정 하에 O(n)

매 분할마다 가장 큰 혹은 가장 작은 원소를 피벗으로 선택하는 경우 n + n − 1 + n − 2 + ⋯ 1→ O(n^2)

- 퀵 선택의 특징
퀵 선택 알고리즘은 각 재귀마다 두 개의 부분 문제로 분할되고, 그 중 한 개의 부분 문제는 고려할 필요가 없다는 점에서 이진 검색 알고리즘과 매우 유사함
하지만 퀵 선택 알고리즘은 주어진 문제가 피벗을 기준으로 비균등하게 부분 문제로 분할하고, 이진 검색 알고리즘은 1/2로 균등하게 부분 문제로 분할