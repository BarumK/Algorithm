- 분할 정복 전략?
주어진 문제를 부분문제로 분할하고(분할) -> 각 부분 해를 찾은 후(정복) -> 통합하여 원래 해결책을 찾는 전략(통합)
why 분할을 하는건지? 입력 크기가 너무 커서 줄이기 위함
    분할: 주어진 문제를 (동일한) 부분 문제들로 (재귀적으로) 분할하고
    정복: 부분 문제들의 부분 해를 찾은 후;
    통합: (필요하다면) 부분 해들을 통합하는 하향식(top-down) 문제 해결 전략
반드시는 아닌데, 거의 대부분 재귀적으로 문제를 해결함
    -> "동일한" 부분 문제들로 해결하기 때문. 다 동일하니까 입력에 대한 사이즈만 다를 뿐, 해결 전랙은 같으니까 사이즈만 줄여서 우선 해결하는거
    입력 사이즈만 다르게 자기 자신만 호출하면 되니까
퀵 정렬, 이진 검색의 경우 통합이 필요없음

- 분할 정복 알고리즘 분류
문제가 각 재귀마다 (1) 두 개의 부분 문제로 분할되고
                (2) 부분 문제의 크기가 1/2 로 감소하는 알고리즘(합병 정렬 알고리즘, 최근접쌍 알고리즘)
문제가 각 재귀마다 (1) 두 개의 부분 문제로 분할되고
                (2) 부분 문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘(퀵 정렬 알고리즘)
문제가 각 재귀마다 (1) 두 개의 부분 문제로 분할되고
                (2) 그 중 한 개의 부분 문제는 고려할 필요가 없으며
                (3) 부분 문제의 크기가 ½ 로 감소하는 알고리즘(이진 검색 알고리즘)
문제가 각 재귀마다 (1) 두 개의 부분 문제로 분할되고
                (2) 그 중 한 개의 부분 문제는 고려할 필요가 없으며
                (3) 부분 문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘(선택 문제 알고리즘)
참고
    최근접쌍 알고리즘: 2차원 상에 n개의 포인트가 주어졌을 때 포인트 사이의 거리가 가장 가까운 포인트의 쌍을 구하는 문제
    선택 문제 알고리즘: 정렬 안된 n개의 숫자가 주어졌을 때 k번째로 작은 숫자를 정하는 문제

- 합병 정렬
자료구조개론에서 다뤘으므로 간단하게 다룸
(i) 사이즈가 n인 하나의 리스트를 두 개의 균등한 크기의 서브리스트로 분할하고
(ii) 각 서브리스트를 재귀적인 방식으로 합병 정렬을 수행하여 정렬한 다음
(iii) 두 개의 정렬된 서브리스트를 합하여 전체가 정렬된 리스트가 되게 하는 분할 정복 정렬 알고리즘
설계 전략
    리스트의 사이즈가 1인 경우 해당 리스트는 정렬된 것으로 간주
    분할: 리스트 내 n 개의 원소 정렬 시 low, mid, high를 찾은 후(low는 가장 왼쪽 인덱스, mid는 중간 인덱스, high는 가장 오른쪽 인덱스),
         두 서브리스트 L[low, mid]와 L[mid+1, high]로 분할(두 서브리스트가 부분 문제)
    정복: 각 서브리스트를 재귀적으로 합병 정렬을 이용하여 정렬(두 서브리스트를 각각 정렬하는 것이 부분 해)
    통합: 두 서브리스트를 다시 하나의 정렬된 리스트로 합병(두 개의 부분 해들을 통합)
예시: AlGoGae_w4_02.png 참고
n의 입력크기가 있다면 추가적으로 n만큼의 추가 메모리공간이 필요함
코드: AlGoGae_w4_03.py 참고

- 합병 정렬 수행 시간 분석
리스트 사이즈(입력 사이즈) n = 2^k 라고 가정
합병 정렬의 분할은 리스트의 중간 인덱스 계산과 2 번의 재귀 호출이므로 상수 시간 소요
단위 연산은 통합(합병)에서의 비교 연산으로 각 통합 단계마다 (n – 1) 번 비교하며, lgn 단계가 존재하므로 시간 복잡도는 O(nlogn)

- 합병 정렬의 특징
입력에 민감하지 않음(input insensitive): 어떠한 입력에 대해서도 항상 O(NlogN) 수행 시간이 소요됨, i.e., 모든 경우의 분석이 가능
정렬 시 추가 메모리 공간이 필요함