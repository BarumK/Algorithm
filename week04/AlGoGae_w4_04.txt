- 퀵 정렬
자료구조개론에서 다뤘으므로 간단하게 다룸
사이즈가 n인 하나의 리스트 내의 특정 원소인 피벗(pivot)을 기준으로
(i) 피벗보다 작은 원소들과 큰 원소들을 좌우로 분리(partition)하여 두 개의 "비균등한 서브리스트"를 구성하고
(ii) 각 서브리스트를 재귀적인 방식으로 퀵 정렬을 수행하여 정렬한 다음
(iii) 두 개의 정렬된 서브리스트를 합하여 전체가 정렬된 리스트가 되게 하는 분할 정복 정렬 알고리즘
비균등하다는 점이 핵심!
거꾸로 정렬되어 있으면 매우 좋지 않은 성능을 가짐
설계 전략
    리스트의 사이즈가 1인 경우 해당 리스트는 정렬된 것으로 간주
    분할: 리스트 내 n 개의 원소 정렬 시 피벗을 기준으로 피벗보다 작은 원소들을 피벗의 왼쪽으로 옮기고, 피벗보다 큰 요소들은 모두 피벗의
         오른쪽으로 옮겨서 두 개의 서브리스트를 생성(추가 공간 X) → 이러한 분할 과정을 partition이라고 함(두 서브 리스트가 부분 문제)
         Note: 본 강의에서는 리스트의 마지막 원소를 피벗으로 선택
    정복: 각 서브리스트를 재귀적으로 퀵 정렬을 이용하여 정렬(두 서브리스트를 각각 정렬하는 것이 부분 해)
    통합: 필요 없음
예시: AlGoGae_w4_05.png 참고
코드: AlGoGae_w4_06.py 참고

- 퀵 정렬 수행 시간 분석
입력 크기 n = 2^k 라고 가정
최선의 경우와 평균의 경우: O(nlogn)
    최선의 경우 합병 정렬과 마찬가지로 k만큼 분할하며, 각 분할마다 약 n번의 원소를 비교(단위 연산은 분할 시 리스트의 원소와 피벗의 비교)
    평균의 경우 피벗의 인덱스가 리스트 전체에 걸쳐서 균등하게 임의로 결정된다는 가정 하에 O(nlogn)
최악의 경우: O(n^2)
    입력이 이미 정렬되어 있거나 역순으로 정렬되어 있다면 n번 분할하며, 각 분할 단계마다 n - 1, n - 2, ... , 1 번의 원소를 비교하므로
    (n * (n - 1)) / 2

- 퀵 정렬의 특징
평균 시간 복잡도가 O(nlogn)인 다른 정렬 알고리즘들보다 빠름(상수적으로 빠르다는 의미)
합병 정렬과 다르게 정렬 시 추가 메모리 공간이 필요하지 않음

- 퀵 정렬과 합병 정렬과의 차이점
합병 정렬은 아무 연산 없이 균등한 두 부분으로 분할하는 반면에, 퀵 정렬은 분할할 때부터 기준 원소(피벗)를 중심으로 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킴
    즉, 정복 과정(정렬 과정)이 분할 과정에서 함께 진행
각 부분 정렬이 끝난 후, 합병 정렬은 통합 과정이라는 후처리 작업이 필요하나, 퀵 정렬은 필요로 하지 않음
