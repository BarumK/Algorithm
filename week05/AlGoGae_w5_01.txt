- 최근접쌍 문제(closest pair problem)
d 차원(본 강의에서 d = 2로 가정) 상에 존재하는 n 개의 점들의 집합이 주어졌을 때, 두 점 사이의 거리(본 강의에서거리는 유클리드 거리로 가정)가 가장 가까운 한 쌍을 찾는 문제
입력: 사이즈(카디널리티:cardinality)가 n인 점들의 집합 -> 본 강의에서는 리스트에 저장
출력: 서로 간의 거리가 가장 가까운 한 쌍
단순한 방법: n 개의 모든 점에 대하여 각각의 두 점 사이의 거리를 계산해서 가장 가까운 쌍을 검색 -> O(n^2)

- 최근접상 문제의 분할 정복 알고리즘 설계 전략: 복잡도가 O(nlogn)이 되게끔
집합의 사이즈 n ≤ 3이면 분할하지 않고 단순한 방법(brute-force)을 사용
분할: n 개의 점들을 x 좌표에 따라 오름차순으로 정렬하고, n 개의 점들의 집합이 두 개의 같은 크기의 서브집합으로 나뉠 수 있도록 y축과 평행한
    직선을 이용해 공간을 분할(두 서브집합이 부분 문제) -> x축 분할 값 또는 x축 분할 점으로 명명
정복: 각 서브집합에서 재귀적으로 두 점 사이의 거리가 가장 가까운 한 쌍을 검색(두 서브집합에서 각각 최근접쌍을 검색하는 것이 정복) -> 왼쪽 서브집합에서
    가장 가까운 한 쌍 cpleft와 오른쪽 서브집합에서 가장 가까운 한쌍 cpright이 검색됨(아래 그림에서 cpleft는 (p2, p4)이고 cpright는 (p5, p6)임)
    반드시 cpleft와 cpright 중 하나가 최종적으로 찾고자 하는 최근접쌍일까? No!
통합: (1) 하나의 점은 왼쪽 서브집합에 속하고, 다른 점은 오른쪽 서브집합에 속하는 쌍들 중 그 거리가 최소가 되는 쌍 cpmid를 찾고
    (2) cpleft, cpright, cpmid 중 두 점 사이의 거리가 가장 가까운 쌍을 선택해서 최종 결과로 반환
통합 과정에서 하나의 점은 왼쪽 서브집합에 속하고 다른 점은 오른쪽 서브집합에 속하는 쌍들의 집합을 T라고 했을 때 T에 속한 쌍 중 cpmid는 어떻게 찾을까?
단순한 방법을 사용한다면 왼쪽 서브집합 사이즈가 n/2 개, 오른쪽 서브집합 사이즈가 n/2 개이므로 총 (n^2)/4번의 거리 계산이 필요
    -> cpmid를 찾는 과정만 O(n^2)이므로 분할 정복 알고리즘을 사용할 이유가 없음
핵심 아이디어
    cpleft의 거리를 dleft라고 하고, cpright의 거리를 dright라고 하고, min(dleft, dright)을 d라고 하면, T에 속한 쌍 중 거리가 d보다 먼 쌍은 고려할 필요가 없음
    그렇다면 T 중 고려할 필요가 없는 쌍을 어떻게 추려낼까(filtering out)? d와 점들의 x좌표를 이용하여 T에 속한 쌍 중 최종 결과가 될가능성이 있는 쌍의 최소 거리에 대한 상한(upper bound)을 통해서 추려 냄
        -> 즉 x좌표를 이용함; d값 중 최소를 정해서 분할점 기준으로 좌우 d만큼만 생각하면 됨
    크기가 n인 점들의 집합이 주어졌을 때 띠(strip) 내부에 존재하는 점들의 쌍에 대한 거리 dmid 계산을 몇 번이나 해야 할까?
    띠 내부에 존재하는 점들을 (1) y좌표에 따라 오름차순 정렬하고
                          (2) 가장 아래에 위치하는 점 p(y좌표 값이 작은 점)에서 자신과 같은 위치(tie가 존재할 경우) 혹은
                            자신보다 더 위에 존재하는(y좌표 값이 자신과 같거나 더 큰) 점과 하나씩 거리를 계산한다고 가정하자.
        이 때, 띠 내부에 p보다 위에 존재하는 점이 50개라고 가정하면 49 번의 거리를 계산할 필요가 있을까? NO!
    띠 내부에 존재하는 점들의 집합을 S (앞의 예제에서 S = {p3, p4, p5, p6}) 가 주어졌을 때, S에 속한 점들의 y좌표를 이용하여 거리 계산 수의 상한을 결정할 수 있음
    S에 속한 점들 중 왼쪽 서브집합에 속한 임의의 점 pi = (xi, yi)와 오른쪽 서브집합에 속한 임의의 점 pj = (xj, yj)가 존재하고
    dist(pi, pj) ≤ d라고 가정(즉, min(dleft, dright, dmid) = dmid). 또한, pi의 y좌표 값이 가장 작다고 가정
정리
    일단 좌우 나눠서 각각 짧은 거 하나씩 가져오고 둘 사이에서 무조건 최소 나오는게 아니니까 중간까지 구해서 셋 중에 짧은 거 구해야 한다
    그럼 중간 값은 어떻게 구하냐? x좌표 어느정도 있는 애들만 추려내서 그 중에서 구함(strip 안의 값들만)
    근데 strip 안에 있는 애들은 얼마만큼 거리 계산할건데? y좌표 어느정도 되는 애들까지만 하는데, 많아봤자 7개까지임(증명 있음, 설명 안함)
예시: AlGoGae_w5_02.png 참고

- 최근접쌍 알고리즘 수행 시간 분석
점들의 집합(리스트)의 사이즈(입력 사이즈) n = 2k 라고 가정했을 때, 전처리 (preprocessing) 과정으로서 점을 x좌표로 정렬 O(nlogn)
최근접쌍 알고리즘의 분할은 합병 정렬과 마찬가지로 상수 시간 소요 O(1)
단위 연산은 통합(합병)에서의 거리 계산으로 각 통합 단계마다 y좌표로 정렬하고, 상수 개 × (𝑛 − 2) 번 거리를 계산하므로 O(nlogn + n) = O(nlogn)
lgn - 1의 통합 단계가 존재하므로 시간 복잡도는 O(nlog^2 n)

- 성능 향상 방법
전처리 과정에서 점들을 y좌표로 정렬한 추가 리스트를 사용하게 되면 O(nlogn)

코드: AlGoGae_w5_03.py 참고