- 알고리즘의 시간 복잡도
시간 복잡도: 입력 크기 n에 따른 단위 연산 수로 복잡도를 정의한 것
    -> 알고리즘의 효율성을 분석하기 위함, n에 대한 함수로 표현 가능
효율적이다 == 단위 연산 수가 적다 == 복잡도가 낮다(덜 복잡하다)
입력 크기에 따라 동일한 여러 복잡도에 대해 효율이 달라질 수도 있음
    예) 0.1 * n^2 와 1000n
    -> 상황에 따라 다르다고만 말할 수는 없음. 어떤 것이 더 좋다라고 말할 필요가 있음. 그래서 알고리즘을 점근적 복잡도로 분석함.

- 알고리즘의 점근적 복잡도
쉽게 말해 입력 값이 충분히(혹은 무한히) 큰 경우일 때 알고리즘의 복잡도(단위연산 수)
n에 대한 함수로 표현되는 복잡도는 최고차 항의 차수가 궁극적으로 지배
    -> 즉, 최고자항만 비교하면 된다는 뜻
예) 팩토리얼 계산에서의 재귀 vs 반복 비교
    재귀는 n번 호출, 반복은 n번 반복을 통해 함수 전개
    따라서 별 차이 없음, 다만 상수적으로는 차이가 있을 수 있음 근데 n이 크면 상수는 무시됨
계산해보면 나오지만, n이 커질수록 전체 값에서 최고차항의 값의 비중이 더욱 커짐, 즉 최고자항 이외의 항은 무시할 수 있음

- 복잡도 카테고리
최고차 항을 기준으로 알고리즘 복잡도의 카테고리를 나눌 수 있음
상수(1), 로그(logn), 선형(n), 로그선형(nlogn), 제곱(n^2), 세제곱(n^3), 지수(2^n) 시간으로 나눌 수 있음
    -> 좌 -> 우로 갈수록 복잡도 높아짐; +) 지수시간보다 더 안좋은 n!이 존재함
why? 상수 무시함 최고차항 이외의 항 무시함.
    -> 특정 알고리즘이 입력 크기가 무한히 커질 때 연산 수가 얼마나 많아지는가를 따지기 위해선 최고차항만 알면 됨

- 정리
(시간) 효율성 분석 -> (시간) 복잡도 분석(효율성이 높을수록 낮음)
    -> 복잡도: 입력 크기에 따른 단위 연산 수
근데 상황(입력 크기)에 따라 다름 -> 이를 해결하기 위해 점근적 복잡도 이용: n이 무한대로 커질 때의 시간 복잡도
    -> 입력 크기 n이 증가하느냐에 따라 단위 연산 수가 어떠한 빠르기로 증가하는 지를 봄; 최고차항을 기준으로!

- 점근적 표기법(자료구조개론에서 다뤘으므로 설명은 간단하게만 기술함)
: 알고리즘의 점근적 복잡도를 표기하는 방법(O, 빅 오메가, 세타, o, 스몰 오메가 표기법이 있음; 본 강의는 앞의 4개만 다룸)
비교 연산 혹은 비교 + 교환 연산으로 해서 최고차항에 들어가는 카테고리에 넣으면 됨
    O(Big-Oh) 표기법
        : 알고리즘 복잡도의 점근적 상한을 표시; 아무리 나빠도 이거보단 나빠지지 않는다라는 뜻 -> 덜 복잡하다, 복잡도의 상한이다
        즉, 더 큰 차수임
        "특정 알고리즘의 복잡도 g(n)은 복잡도 함수 f(n)의 Big-Oh에 속한다"로 표기
        어떤 n0과 c를 선택하든 간에 이 두개가 존재하기만 함을 증명하기만 하면 됨
    Omega 표기법
        : 알고리즘 복잡도의 점근적 하한을 표시; 아무리 좋아도 이것보단 좋아지지 않는다라는 뜻 -> 더 복잡하다, 복잡도의 하한이다
        즉, 더 작은 차수임
        "특정 알고리즘의 복잡도 g(n)은 복잡도 함수 f(n)의 Omega에 속한다"로 표기
        마찬가지로 어떤 n0과 c를 선택하든 간에 이 두개가 존재하기만 함을 증명하기만 하면 됨
    Theta 표기법
        : Big-Oh와 Omega의 교집합.
        "특정 알고리즘의 복잡도 g(n)은 복잡도 함수 f(n)와 동일한 차수이다"
    o(Small-Oh) 표기법
        : (거의 쓰이지 않음) Big-Oh의 조건에서 추가적으로 조건이 더 붙음.
        음이 아닌 정수 n0, "모든 양의 실수 c"(중요!)
        "특정 알고리즘의 복잡도 g(n)은 복잡도 함수 f(n)의 Small-Oh에 속한다"로 표기