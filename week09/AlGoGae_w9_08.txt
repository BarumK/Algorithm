- 동적 프로그래밍: 어떠한 문제를 해결할 때 동적 프로그래밍을 사용하는가?
1. 특정 문제를 분할 정복 시, 분할된 부분 문제들이 완벽히 동일하게 중복으로 존재해야 함(overlapping sub-problem property)
    n번째 피보나치 수 구하기 문제와는 다르게 계승(factorial) 구하기, 합병 정렬, 퀵 정렬, 이진 검색 등은 중복된 부분 문제가 존재하지 않음
    ex1) 계승 구하기 문제
        AlGoGae_w9_09.png 참고
        부분 문제에 대한 해를 기록한 후 해당 부분 문제와 완벽히 동일한 부분 문제 해결 시 기록된 해를 재사용하자는 것이 동적 프로그래밍의 가장 중요한 동기인데
        중복된 부분 문제가 존재하지 않으므로 (disjoint sub-problem property) 기록할 필요가 없음
    ex2) 퀵 정렬
        AlGoGae_w9_10.png 참고
        동일한 부분 문제가 존재 하는가? No! 계승 문제와 마찬가지로 중복된 완벽히 동일한 부분 문제가 존재하지 않으므로 기록할 필요가 없음
    -> 결론 1: 부분 문제로 분할 시 완벽히 동일한 부분 문제가 중복 될 경우에(주어진 문제가 overlapping sub-problem 특성을 만족할 경우에)
              분할 정복 전략 대신 동적 알고리즘을 사용하면 수행 시간을 줄일 수 있음
    보통 동적 프로그래밍은 분할 정복 전략을 선택했을 때 수행 시간이 지수 시간이 걸리는 것을 polynomial 시간으로 바꿈
2. 특정 문제를 분할 정복 시, 해당 문제에 대한 최적 해가 분할된 부분 문제들의 최적 해들로 구성이 되어야 함(최적의 하위 구조: optimal sub-structure property)
    ex1) n번째 피보나치 수 구하기 문제: fib(5) = fib(4) + fib(3)
        특정 문제에 대한 최적의 해란 다수의 해가 존재할 때 그 중 최적인 해를 의미하는데,
        피보나치 수 구하기 문제의 경우 문제에 대한 해(fib(5))가 단 하나이므로 해당 해가 최적 해임
    ex2) (무방향·방향) 그래프 상 최단 경로 문제: 아래 그래프에서 정점 A에서 정점 E까지의 최단 경로
        AlGoGae_w9_11.png 참고
    -> 결론 2: 주어진 문제가 최적의 하위 구조 특성을 만족할 경우에만 동적 프로그래밍을 사용할 수 있음

- 동적 프로그래밍 예시: n번째 피보나치 수(Fibonacci number) 구하기
동적 프로그래밍은 주어진 문제를 분할 후 더 작은 부분 문제들의 해를 먼저 찾은 후 이들을 통합하여 더 큰 문제의 해를 찾는 상향식(bottom-up) 문제 해결 전략으로,
메모 전략과 마찬가지로 부분 문제들의 해를 기록(tabulation)하여 완벽히 동일한 부분 문제의 해를 다시 찾아야 할 경우 저장된 해를 재사용
    -> 즉, 분할 정복 전략은 위에서 시작하여 문제의 최종 해를 찾기 위한 계산을 해 나가는 반면에, 동적 프로그래밍은 밑에서 시작하여 결과를 기록하면서 문제의 최종 해를 찾아 나감
AlGoGae_w9_12.py & AlGoGae_w9_13.png 참고
입력 크기 n에 대한 모든 경우의 수행 시간을 T(n)이라고 하면: T(n)은 라인 3-4와 라인 5-6의 연산문의 총 수로 2 + (n – 1) = n + 1, 즉 O(n)
피보나치 수 구하기를 했을 때 메모 전략 vs 동적 프로그래밍?
    동적 프로그래밍이 더 빠름. 수행 시간 측면에선 같으나 상수적으로 더 빠름
    why? recursion은 시스템 스택을 사용함 -> 이럴 경우 오버헤드가 발생함(어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다)
    이러한 재귀를 메모 전략은 사용하지만 동적 프로그래밍은 사용할 이유가 없음, 반복이 더 빠르니까
