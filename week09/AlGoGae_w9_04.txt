- 동적 프로그래밍 예: n번째 피보나치 수(Fibonacci number) 구하기
피보나치 수열의 순환식(recurrence: 점화식)
    f0 = 0, f1 = 1, fn = f(n - 1) + f(n - 2) for n >= 2

- 분할 정복 전략(recursion)
AlGoGae_w9_05.py 참고
5번째 피보나치 수를 구하는 과정에서 완벽히 동일한 부분 문제가 중복(3번째 피보나치 수를 구하는 부분 문제 fib(3) 2번,
2번째 피보나치 수를 구하는 부분 문제 fib(2) 3번, 1번째 피보나치 수를 구하는 부분 문제 fib(1) 4번, 0번째 피보나치 수를
구하는 부분 문제 fib(0) 3번) -> 수행 시간: O(2^n)
중복된 (완벽히 동일한) 부분 문제 해결 과정을 제거하게 된다면 수행 시간을 선형 시간, i.e., O(n)으로 줄일 수 있음
어떻게 중복된 부분 문제 해결 과정을 제거할 수 있을까?
    ->부분 문제에 대한 해를 기록한 후 해당 부분 문제와 완벽히 동일한 부분 문제 해결 시 기록된 해를 (재)사용
        -> 두 가지 전략: 메모 전략 & 동적 프로그래밍
        NOTE: 둘을 구분하는 것이 좋음! 메모 전략은 top-down 방식이고 동적 프로그래밍은 bottom-up 방식임

- 메모 전략(memoization)
AlGoGae_w9_06.png 참고
특정 문제를 분할 정복 시 (특정 문제를 재귀 호출을 이용하여 문제의 최종 해를 찾을 시) 특정 부분 문제의 해를 찾게 되면 이를 기록해 놓고,
완벽히 동일한 문제의 해를 다시 찾아야 할 경우 함수를 호출하지 않고 저장된 해를 재사용하는 전략
NOTE: 분할 정복 및 메모 전략은 하향식(top-down) 문제 해결 방식
T(n) = O(n), 선형 시간이 됨
메모 전략을 이용한 피보나치 수 구하기 문제 해결을 위한 fib_memoized 함수 정의
    AlGoGae_w9_07.py 참고
메모 전략을 하향식 동적 프로그래밍이라고도 지칭하는 경우도 있지만, 엄밀히 말하면 동적 프로그래밍이 아님
-> 따라서 메모 전략과 동적 프로그래밍을 서로 별개로 간주하는 것을 추천

-TIP
나중에 문제 해결을 위해 바로 동적 프로그래밍을 사용하기 어려움
그 전에 분할 정복 전략을 이용하여 순환식을 작성하고 메모 전략으로 바꿀 수 있는지 확인 후, 변경이 가능하면 DP로 바꾸는 방식을 추천함
단계를 거치는 것이 필요없어 보이지만 이 방식이 쉬우니 사용하는 것이 좋음
