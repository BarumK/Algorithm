- 효율적인 알고리즘 설계의 중요성 – 선형검색 vs. 이진검색
선형검색
    문제: 크기가 n인 리스트 L에 x라는 수가 존재하는가?
    매개변수(입력): (1) 리스트 L, (2) 양수 n, (3) 검색키 x
    출력: 존재하면 L에서 x의 위치, 존재하지 않으면 Not found
    선형검색 알고리즘으로 x가 존재하는지 확인하기 위해서 리스트 L에 있는 항목을 몇 개나 확인해야 할까?
                                                ~~~~~~
                                                  L 임의의 순서로 항목들을 나열함 선형 구조, 논리적인 구조(사람의 생각대로 나열),
                                                    컴퓨터에 직접적으로 구현함.
        AlGoGae_w2_02.py 참조
    최악의 경우(x가 리스트의 마지막에 존재하거나 리스트에 존재하지 않을 경우): n 개 확인
    더 빠르게 검색할 수는 없을까? -> 리스트 L이 정렬되어 있지 않다면 불가능. 정렬이 안되어있을 시엔 더 좋은 방법은 존재하지 않음.
                             -> 자료구조의 중요성, 자료구조를 어떻게 선택하느냐에 따라 더 좋은 알고리즘을 사용할 수 있음.
                                따라서 알고리즘에는 자료구조가 따라 들어감.
                                자료구조: 데이터를 논리적으로 나열한 다음 효과적으로 컴퓨터에 저장하는 방법과 연산

    선형 검색 알고리즘은 brute-force 전략의 결과물임.
    Brute-force? 문제의 해결책이 될 수 있는 모든 후보들을 하나하나 확인하면서 해결책을 찾아내는 전략.
        왜 필요한가? 무식하지만 반드시 유한한 시간 내에 정답을 찾아낼 수 있음. 정확성을 보장함.
        특정 전략을 사용해 설계한 알고리즘이 정확한 해결을 내놓는지를 확인하기 위해 brute-force 전략으로 뽑아낸 결과와 비교해봄.
        두 결과가 동일할 시 해당 알고리즘이 정확하다고 볼 수 있음.
        또한 효율성 면에서도 좋을 수 있다. 다차원 데이터 처리에서 이 전략이 유리할 수 있다.
        차원이 커지면 커질수록 다른 어떠한 알고리즘도 brute-force 방식을 사용한 알고리즘보다 결과가 좋지 않음.
        -> 이를 "차원의 저주"라고 함(curse of dimensionality)

이진검색(binary search)
    문제: 크기가 n인 "정렬된" 리스트 L에 x라는 수가 존재하는가?
    -> 정렬되어 있어야 한다!!
    매개변수(입력): (1) 정렬된 리스트 L, (2) 양수 n, (3) 검색키 x
    출력: 존재하면 L에서 x의 위치, 존재하지 않으면 Not found
        AlGoGae_w2_03.py 참조
    최악의 경우(x가 리스트에 존재하지 않을 경우)?
    while 문을 수행할 때마다 검색 대상의 크기가 절반으로 감소하기 때문에, n = 2^k라고 하면 최악의 경우 log 2^k + 1 = log n + 1번을 비교
                          ~~~~~~~~
                            L 검색 대상을 보통 Search Space라고 한다

선형검색 vs 이진검색
    리스트 크기                  선형검색                    이진검색                    비고
            n                        n                 log n + 1              두 알고리즘
          128                      128                         8                    모두
         1024                     1024                        11            최악의 경우에
      1048576                  1048576                        21                    대한
   4294967296               4294967296                        33              비교 횟수임
   -> 입력 크기가 커질 수록 더욱 차이가 커짐. 선형검색은 선형적으로 증가하는 반면, 이진검색은 로그적으로 증가함.

- 효율적인 알고리즘 설계의 중요성 – 피보나치 수열(재귀 vs. 반복)
피보나치 수열(Fibonacci sequence)의 정의
    0 번째 항은 0, 첫 번째 항은 1, 그 외 항은 전번, 전전번 항의 합으로 표현되는 단조 증가 수열(monotone increasing sequence)로
    다음과 같은 점화식으로 정의할 수 있음
        f0 = 0
        f1 = 1
        fn = fn-1 + fn-2, for n >= 2
    예: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …
    재귀 호출을 사용하면 굉장히 안 좋은 예를 보여줄 때 많이 사용되는 예시
    피보나치 수열에 대한 문제 해결 시에는 반복을 사용하는 것이 좋음.

재귀(recursion) 알고리즘을 이용한 피보나치 수열의 n 번째 항 구하기
    입력: 음이 아닌 정수 n (0도 되니까)
    출력: n 번째 피보나치 수
        AlGoGae_w2_04 참조
    분석: 재귀 알고리즘을 이용한 n 번째 피보나치 수 구하기는 계산 과정에서 동일한 피보나치 수를 중복하여 계산하므로 비효율적임 (예: fib(2)를 세 번 중복 호출)
    5 번째 피보나치 수를 계산하기 위한 재귀 호출을 보여주는 트리 구조(recursive tree: 재귀 트리): 강의 PDF 그림 참고(Pg.10)
        재귀 호출 순서가 이해가 안간다면 자료구조개론 강의정리 참조 혹은 따로 공부 필요.
    fib(n) 함수 호출 계산
        T(n): fib(n)을 계산하기 위하여 fib() 함수를 호출하는 횟수
        즉, T(n)은 재귀 트리 상의 노드(node) 수
        T(0) = T(1) = 1;
        T(n) = T(n - 1) + T(n - 2) + 1 for n >= 2 (+ 1의 의미: 자기 자신 호출 횟수)
             > 2 * T(n - 2)                 Note: T(n - 1) > T(n - 2) 이유? T(n - 1) = T(n - 2) + T(n - 3) + 1이기 때문
             > 2 * 2 * T(n - 4)
             ...
             > 2 * 2 * ... * 2 * T(0) = 2^(n / 2) -> 좋지 않은 알고리즘임. 지수이기 때문에
               ~~~~~~~~~~~~~~~
                   L n / 2번
            n               트리 상의 노드 수
            0                            1
            1                            1
            2                            3
            3                            5
            4                            9
            5                           15
            6                           25

반복(iterative) 알고리즘을 이용한 피보나치 수열의 n 번째 항 구하기
    입력: 음이 아닌 정수 n
    출력: n 번째 피보나치 수
        AlGoGae_w2_05 참조
    분석: 중복 계산이 없으므로 반복 알고리즘이 재귀 알고리즘보다 효율적임
        T(n): 계산하는 연산문(memo[i])의 총 개수로 memo[0]부터 memo[n]까지 단 한번씩만 계산
        T(n) = n + 1
        -> 선형적으로 증가, 따라서 피보나치 수열에서 특정 n번째 항을 구하는 알고리즘을 작성할 시에는 반복 알고리즘이 좋음
    피보나치 수열의 n 번째 항 구하기 위한 재귀 알고리즘은 "분할 정복(divide and conquer) 전략"을 통해 설계된 알고리즘이며,
    반복 알고리즘은 "동적 프로그래밍(dynamic programming) 전략"을 통해 설계된 알고리즘임

반복 알고리즘이 재귀 알고리즘보다 항상 효율적인가?
    대부분의 경우 반복 알고리즘이 재귀 알고리즘보다 효율적임
    하지만 알고리즘 설계 단계에서 재귀 알고리즘은 매우 유용하며, 때로는 재귀적으로 설계해도 매우 효율적일 수 있음
    재귀 호출 횟수와 반복의 횟수가 동일하면 재귀 알고리즘과 반복 알고리즘의 효율성은 비슷함
        반복 알고리즘이 상수적(constant factor)으로만 더 효율적임
        예: factorial 계산
            AlGoGae_w2_06 참조

- 시간 효율성과 공간 효율성
정확성이 보장되면 효율성을 생각해야 함
시간 효율성(time efficiency)은 문제를 해결하는데 얼마나 많은 시간을 요하는가를 지칭
공간 효율성(space efficiency)은 문제를 해결하는데 얼마나 많은 공간을 필요로 하는가를 지칭
일반적으로 시간 효율성이 공간 효율성보다 더욱 강조가 됨
    그 이유는 시간이 공간보다 비싸기 때문임(시간 효율성은 CPU 성능과 직결되며 공간 효율성은 메모리 용량과 직결됨)
    CPU가 메모리보다 더 비싸...
시간·공간 효율성을 뒤집어 표현한 것이 시간·공간 복잡도(complexity) -> 복잡도가 높을수록 효율성이 저하
알고리즘의 효율성은 복잡도에 기반하여 분석 -> 복잡도가 낮으면 효율적인 알고리즘

- 알고리즘의 시간 복잡도(time complexity) 분석
직접 실행하면서 실제 동작 시간을 측정하는 방법도 좋긴 하나, 어디서 어떤 조건으로 실행했는지에 따라 달라짐. 하드웨어 성능이 영향을 미침.
-> 이러면 정확한 분석이 아님. 하드웨어 성능과 프로그래머의 역량과는 독립적인 분석 방법이 필요함. -> 단위 연산 기준
입력 크기에 따라서 단위 연산이 몇 번 수행되는지 결정하는 절차
    입력 크기: 리스트 크기(예: 선형 검색, 이진 검색), 트리의 노드 수, 그래프의 정점(vertex)과 간선(edge)의 수 등
    단위 연산: 알고리즘을 수행하는 데 있어서 가장 "핵심적인 역할을 담당하는 연산"으로 비교문에 있는 비교 연산(예: 선형 검색, 이진 검색),
              할당문에 있는 수치 연산 후 할당 연산(예: 리스트 내의 모든 항목의 값 더하기) 등
                    ***핵심적인 역할을 담당하는 연산을 주관적으로 선택***
                    하지만 대부분의 전문가들은 동일한 기본 연산을 선택하게 되며, 서로 다른 기본 연산을 선택하더라도
                    최종적인 시간 복잡도는 동일하게 될 정도로 유사한 중요도를 지닌 단위 연산을 택함

단위연산 선택의 중요성
    선택 정렬을 예시로 들자. L = [7, 5, 13, 9, 8, 17]인 리스트 L을 오름차순 정렬하고 싶다고 가정하자.
    각 항목을 다 비교 해서 가장 작은 것을 찾음 -> 가장 작은 값을 가장 왼쪽의 수와 자리를 교환한 후 그것을 제외한 나머지에 대해 반복 수행
                                  비교          할당
        1: [5, 7, 13, 9, 8, 17]    5회           1회
        2: [5, 7, 13, 9, 8, 17]    4회           0회
        3: [5, 7, 8, 9, 13, 17]    3회           1회
        4: [5, 7, 8, 9, 13, 17]    2회           0회
        5: [5, 7, 8, 9, 13, 17]    1회           0회
        합:                       15회           2회
    입력 크기가 n이라면 (n - 1) + (n - 2) + ... + 1 = (n * (n - 1)) / 2번 비교함
    할당은 매번 할당한다 가정시 최대 n - 1번 할당함.
    이 경우 비교와 할당 중 어떤 것을 선택해야 하나? 비교를 하거나 비교 + 할당을 선택해야 한다. (둘은 결론적으로는 복잡도가 같다.)
    할당을 선택하면 안된다. 안봐도 알잖슴; 할당 선택시 유일무이한 엄청난 효율의 정렬방식 탄생임

복잡도 분석
    입력의 크기에 따라 단위 연산이 몇번 수행되느냐?

- (시간) 복잡도 분석 방법의 종류
입력의 크기는 항상 중요한 역할을 한다. 가장 중요한 키 역할을 함

모든 경우 분석(every-case analysis)
    복잡도는 입력 크기 n에만 종속(dependent)적임
    입력 값(입력 내용)과는 무관(independent)하게 복잡도는 항상 일정
    -> 입력의 값에는 영향을 받지 않는다
    복잡도 표기 방법: T(n)
    예: 리스트 내의 모든 항목의 값 더하기
        문제: 크기가 n인 리스트 L의 모든 항목의 값을 더하라
        입력: (1) 리스트 L, (2) 양수 n
        출력: L 내의 모든 항목의 합
        입력 크기: n
            AlGoGae_w2_07.py 참조
        단위 연산: result = result + lst[i] (수치 연산 후 할당 연산)
        리스트 L에 있는 항목 값에 상관 없이 for 루프를 n번 실행하므로 시간 복잡도 T(n) = n

최악의 경우 분석(worst-case analysis)
    복잡도는 입력 크기 n과 입력 값 모두에 종속
    단위 연산이 수행되는 횟수가 최대(최악)인 경우 선택
    복잡도 표기 방법: W(n)
    예: 선형 탐색 알고리즘에 대한 최악의 경우 분석 -> 검색에 관한 알고리즘은 입력값에 영향을 받을 수 밖에 없음
        문제: 크기가 n인 리스트 L에 x라는 수가 존재하는가?
        입력: (1) 리스트 L, (2) 양수 n (3) 찾고자 하는 값 x
        출력: 존재하면 L에서 x의 위치, 존재하지 않으면 -1
        입력 크기: n
            AlGoGae_w2_08.py 참조
        단위 연산: if lst[i] == x (비교문에 있는 비교 연산)
        x가 리스트의 마지막에 존재하거나 리스트에 존재하지 않을 경우 단위 연산이 n번 수행되므로 W(n) = n
        선형 탐색 알고리즘은 리스트 항목 값에 따라서 검색하는 횟수가 달라지므로 모든 경우 분석이 불가능

최선의 경우 분석(best-case analysis)
    복잡도는 입력 크기와 입력 값 모두에 종속
    단위 연산이 수행되는 횟수가 최소(최선)인 경우 선택
    복잡도 표기 방법: B(n)
    예: 선형 검색 알고리즘에 대한 최선의 경우 분석
        문제: 크기가 n인 리스트 L에 x라는 수가 존재하는가?
        입력: (1) 리스트 L (2) 양수 n (3) 찾고자 하는 값 x
        출력: 존재하면 L에서 x의 위치, 존재하지 않으면 -1
        입력 크기: n
            AlGoGae_w2_08.py 참조
        단위 연산: if lst[i] == x (비교문에 있는 비교 연산)
        x가 리스트의 처음에 존재할 경우 단위 연산이 1번 수행되므로 B(n) = 1

평균의 경우 분석(best-case analysis)
    복잡도는 입력 크기와 입력 값 모두에 종속
    모든 입력에 대해서 단위 연산이 수행되는 횟수의 기대치(평균)
    복잡도 표기 방법: A(n)
    확률적 계산이 필요함
        각 입력 값에 대해서 확률 할당이 다를 수 있음: 예를 들어 1부터 100까지 수의 정렬된 값을 가지는 리스트를 순차적으로 검색하는 경우,
        검색하고자 하는 값이 90보다 큰 경우가 더 많다면 평균 단위 연산 수행 횟수는 검색하고자 하는 값이 골고루 분포되는 경우(균등분포)와 다름
        일반적으로는 검색하고자 하는 값이 골고루 분포하는 경우를 가정함. 즉 균등분포를 가정함
    예: 선형 탐색 알고리즘에 대한 평균의 경우 분석
        문제: 크기가 n인 리스트 L에 x라는 수가 존재하는가?
        입력: (1) 리스트 L, (2) 양수 n (3) 찾고자 하는 값 x
        출력: 존재하면 L에서 x의 위치, 존재하지 않으면 -1
        입력 크기: n
            AlGoGae_w2_08.py 참조
        단위 연산: if lst[i] == x (비교문에 있는 비교 연산)
    가정: 균등분포, L 내의 모든 항목이 서로 다른 값을 가짐
    경우 1: x가 L 내에 반드시 존재하는 경우만 고려
        1 <= i <= n에 대해서 x가 L의 i번째에 존재할 확률 = 1 / n
        x가 L의 k번째에 존재한다면 x를 찾기 위해서 수행하는 단위 연산의 횟수는 i번이므로
        A(n) = 시그마(i * (1 / n)) (i가 1부터 n까지) = (n + 1) / 2
    경우 2: x가 L 내에 존재하지 않을 경우도 고려
        x가 L 내에 존재할 확률을 p라고 하면.
            x가 L 내에 i번째 있을 확률 = p / n
            x가 L 내에 존재하지 않을 확률 = 1 - p
            따라서 A(n) = 시그마(i * (p / n)) (i가 1부터 n까지) + n * (1 - p) = n * (1 - (p / 2)) + p / 2

최악, 최선, 평균의 경우 분석 방법 중에서 어떤 분석을 사용할 것인가?
    일반적으로 최악 혹은 평균의 경우 분석 방법을 사용
    모든 경우의 분석이 가능하다면 최악 최선 평균이 모두 동일함. 입력의 값과는 상황이 없기 때문.